<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

<canvas id="canvas" width="300" height="300"></canvas>

<script>

    var modules = {};
    function require(name){
        var moduleObj = modules[name];
        if (!moduleObj) throw 'no such module: ' + name;
        if (!moduleObj._exports) initModule(moduleObj);
        return moduleObj._exports.exports;
    }
    var initModule = function(moduleObj){
        moduleObj._exports = {
            exports:{}
        };
        moduleObj.exports(moduleObj._exports);
    };

    modules.GlUtils = {
        exports: function(module){

            var Mat4 = require('Mat4');

            function compileShader(gl, shaderSource, shaderType) {
                // Create the shader object
                var shader = gl.createShader(shaderType);
                gl.shaderSource(shader, shaderSource);
                gl.compileShader(shader);

                // Check the compile status
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error(gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }


            module.exports.createProgram = function (gl, vShaderSource, fShaderSource) {
                var program = gl.createProgram();
                var vShader = compileShader(gl, vShaderSource, gl.VERTEX_SHADER);
                var fShader = compileShader(gl, fShaderSource, gl.FRAGMENT_SHADER);
                if (!(vShader && fShader)) {
                    console.error('Could not compile shader');
                    return null;
                }
                gl.attachShader(program, vShader);
                gl.attachShader(program, fShader);
                gl.linkProgram(program);

                // Check the linking status
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Could not initialize shader');
                    console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
                    console.error('gl.getError()', gl.getError());
                    // if there is a program info log, log it
                    if (gl.getProgramInfoLog(program) !== '') {
                        console.warn('Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
                    }

                    gl.deleteProgram(program);
                    program = null;
                    return null;
                }
                return program;
            };


            module.exports.extractUniforms = function (gl, program) {
                var uniforms = {};

                var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

                for (var i = 0; i < totalUniforms; i++) {
                    var uniformData = gl.getActiveUniform(program, i);
                    var name = uniformData.name.replace(/\[.*?]/, "");
                    var type = mapType(gl, uniformData.type);

                    uniforms[name] = {
                        type: type,
                        size: uniformData.size,
                        name: name,
                        location: gl.getUniformLocation(program, name)
                        //value:defaultValue(type, uniformData.size)
                    };
                }

                return uniforms;


                function mapType(gl, type) {

                    var GL_TABLE = null;

                    var GL_TO_GLSL_TYPES = {
                        'FLOAT': 'float',
                        'FLOAT_VEC2': 'vec2',
                        'FLOAT_VEC3': 'vec3',
                        'FLOAT_VEC4': 'vec4',

                        'INT': 'int',
                        'INT_VEC2': 'ivec2',
                        'INT_VEC3': 'ivec3',
                        'INT_VEC4': 'ivec4',

                        'BOOL': 'bool',
                        'BOOL_VEC2': 'bvec2',
                        'BOOL_VEC3': 'bvec3',
                        'BOOL_VEC4': 'bvec4',

                        'FLOAT_MAT2': 'mat2',
                        'FLOAT_MAT3': 'mat3',
                        'FLOAT_MAT4': 'mat4',

                        'SAMPLER_2D': 'sampler2D'
                    };

                    if (!GL_TABLE) {
                        var typeNames = Object.keys(GL_TO_GLSL_TYPES);

                        GL_TABLE = {};

                        for (var i = 0; i < typeNames.length; ++i) {
                            var tn = typeNames[i];
                            GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
                        }
                    }

                    return GL_TABLE[type];
                }
            };


            module.exports.getUniformSetter = function(uniform){
                if (uniform.size==1) {
                    switch (uniform.type) {
                        case 'float':       return function(gl,location,value) {gl.uniform1f(location, value)};
                        case 'vec2':        return  function(gl,location,value) {gl.uniform2f(location, value[0], value[1])};
                        case 'vec3':        return  function(gl,location,value) {gl.uniform3f(location, value[0], value[1], value[2])};
                        case 'vec4':        return  function(gl,location,value) {gl.uniform4f(location, value[0], value[1], value[2], value[3])};
                        case 'int':         return  function(gl,location,value) {gl.uniform1i(location, value)};
                        case 'ivec2':       return  function(gl,location,value) {gl.uniform2i(location, value[0], value[1])};
                        case 'ivec3':       return  function(gl,location,value) {gl.uniform3i(location, value[0], value[1], value[2])};
                        case 'ivec4':       return  function(gl,location,value) {gl.uniform4i(location, value[0], value[1], value[2], value[3])};
                        case 'bool':        return  function(gl,location,value) {gl.uniform1i(location, value)};
                        case 'bvec2':       return  function(gl,location,value) {gl.uniform2i(location, value[0], value[1])};
                        case 'bvec3':       return  function(gl,location,value) {gl.uniform3i(location, value[0], value[1], value[2])};
                        case 'bvec4':       return  function(gl,location,value) {gl.uniform4i(location, value[0], value[1], value[2], value[3])};
                        case 'mat2':        return  function(gl,location,value) {gl.uniformMatrix2fv(location, false, value)};
                        case 'mat3':        return  function(gl,location,value) {gl.uniformMatrix3fv(location, false, value)};
                        case 'mat4':        return  function(gl,location,value) {gl.uniformMatrix4fv(location, false, value)};
                        case 'sampler2D':   return  function(gl,location,value) {gl.uniform1i(location, value)};
                    }
                } else {
                    switch (uniform.type) {
                        case 'float':       return  function(gl,location,value) {gl.uniform1fv(location, value)};
                        case 'vec2':        return  function(gl,location,value) {gl.uniform2fv(location, value)};
                        case 'vec3':        return  function(gl,location,value) {gl.uniform3fv(location, value)};
                        case 'vec4':        return  function(gl,location,value) {gl.uniform4fv(location, value)};
                        case 'int':         return  function(gl,location,value) {gl.uniform1iv(location, value)};
                        case 'ivec2':       return  function(gl,location,value) {gl.uniform2iv(location, value)};
                        case 'ivec3':       return  function(gl,location,value) {gl.uniform3iv(location, value)};
                        case 'ivec4':       return  function(gl,location,value) {gl.uniform4iv(location, value)};
                        case 'bool':        return  function(gl,location,value) {gl.uniform1iv(location, value)};
                        case 'bvec2':       return  function(gl,location,value) {gl.uniform2iv(location, value)};
                        case 'bvec3':       return  function(gl,location,value) {gl.uniform3iv(location, value)};
                        case 'bvec4':       return  function(gl,location,value) {gl.uniform4iv(location, value)};
                        case 'sampler2D':   return  function(gl,location,value) {gl.uniform1iv(location, value)};
                    }
                }
            };



            module.exports.MatrixStack = function () {
                var self = this;
                this.stack = [];

                this.restore = function () {
                    this.stack.pop();
                    // Never let the stack be totally empty
                    if (this.stack.length < 1) {
                        this.stack[0] = Mat4.makeIdentity();
                    }
                };

                this.save = function () {
                    this.stack.push(this.getCurrentMatrix());
                };

                this.getCurrentMatrix = function () {
                    return this.stack[this.stack.length - 1].slice();
                };

                this.setCurrentMatrix = function (m) {
                    return this.stack[this.stack.length - 1] = m;
                };

                this.translate = function (x, y, z) {
                    if (z === undefined) {
                        z = 0;
                    }
                    var t = Mat4.makeTranslation(x, y, z);
                    var m = this.getCurrentMatrix();
                    this.setCurrentMatrix(Mat4.matrixMultiply(t, m));
                };

                this.rotateZ = function (angleInRadians) {
                    var t = Mat4.makeZRotation(angleInRadians);
                    var m = this.getCurrentMatrix();
                    this.setCurrentMatrix(Mat4.matrixMultiply(t, m));
                };

                this.rotateY = function (angleInRadians) {
                    var t = Mat4.makeYRotation(angleInRadians);
                    var m = this.getCurrentMatrix();
                    this.setCurrentMatrix(Mat4.matrixMultiply(t, m));
                };

                this.scale = function (x, y, z) {
                    if (z === undefined) {
                        z = 1;
                    }
                    var t = Mat4.makeScale(x, y, z);
                    var m = this.getCurrentMatrix();
                    this.setCurrentMatrix(Mat4.matrixMultiply(t, m));
                };

                (function () {
                    self.restore();
                })();

            };

        }
    };


    modules.Mat4 = {

        exports: function(module){

            var exports = module.exports;

            exports.makeIdentity = function () {
                return [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ];
            };

            exports.make2DProjection = function (width, height, depth) {
                // Note: This matrix flips the Y axis so 0 is at the top.
                return [
                    2 / width, 0, 0, 0,
                    0, - 2 / height, 0, 0,
                    0, 0, 2 / depth, 0,
                    -1, 1, 0, 1
                ];
            };

            exports.makePerspective = function (fieldOfViewInRadians, aspect, near, far) {
                var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);
                var rangeInv = 1.0 / (near - far);

                return [
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (near + far) * rangeInv, -1,
                    0, 0, near * far * rangeInv * 2, 0
                ];
            };

            exports.makeZToWMatrix = function(fudgeFactor) {
                return [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, fudgeFactor,
                    0, 0, 0, 1
                ];
            };

            exports.makeTranslation = function (tx, ty, tz) {
                return [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    tx, ty, tz, 1
                ];
            };

            exports.makeXRotation = function (angleInRadians) {
                var c = Math.cos(angleInRadians);
                var s = Math.sin(angleInRadians);

                return [
                    1, 0, 0, 0,
                    0, c, s, 0,
                    0, -s, c, 0,
                    0, 0, 0, 1
                ];
            };

            exports.makeYRotation = function (angleInRadians) {
                var c = Math.cos(angleInRadians);
                var s = Math.sin(angleInRadians);

                return [
                    c, 0, -s, 0,
                    0, 1, 0, 0,
                    s, 0, c, 0,
                    0, 0, 0, 1
                ];
            };

            exports.makeZRotation = function (angleInRadians) {
                var c = Math.cos(angleInRadians);
                var s = Math.sin(angleInRadians);
                return [
                    c, s, 0, 0,
                    -s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ];
            };

            exports.makeScale = function (sx, sy, sz) {
                return [
                    sx, 0, 0, 0,
                    0, sy, 0, 0,
                    0, 0, sz, 0,
                    0, 0, 0, 1
                ];
            };

            exports.matrixMultiply = function (a, b) {
                var a00 = a[0 * 4 + 0];
                var a01 = a[0 * 4 + 1];
                var a02 = a[0 * 4 + 2];
                var a03 = a[0 * 4 + 3];
                var a10 = a[1 * 4 + 0];
                var a11 = a[1 * 4 + 1];
                var a12 = a[1 * 4 + 2];
                var a13 = a[1 * 4 + 3];
                var a20 = a[2 * 4 + 0];
                var a21 = a[2 * 4 + 1];
                var a22 = a[2 * 4 + 2];
                var a23 = a[2 * 4 + 3];
                var a30 = a[3 * 4 + 0];
                var a31 = a[3 * 4 + 1];
                var a32 = a[3 * 4 + 2];
                var a33 = a[3 * 4 + 3];
                var b00 = b[0 * 4 + 0];
                var b01 = b[0 * 4 + 1];
                var b02 = b[0 * 4 + 2];
                var b03 = b[0 * 4 + 3];
                var b10 = b[1 * 4 + 0];
                var b11 = b[1 * 4 + 1];
                var b12 = b[1 * 4 + 2];
                var b13 = b[1 * 4 + 3];
                var b20 = b[2 * 4 + 0];
                var b21 = b[2 * 4 + 1];
                var b22 = b[2 * 4 + 2];
                var b23 = b[2 * 4 + 3];
                var b30 = b[3 * 4 + 0];
                var b31 = b[3 * 4 + 1];
                var b32 = b[3 * 4 + 2];
                var b33 = b[3 * 4 + 3];
                return [a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30,
                    a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31,
                    a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32,
                    a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33,
                    a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30,
                    a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31,
                    a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32,
                    a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33,
                    a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30,
                    a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31,
                    a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32,
                    a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33,
                    a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30,
                    a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31,
                    a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32,
                    a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33];
            };
        }

    };

    modules.ShaderSources = {
        exports: function(module){
            module.exports.SHADERS_SRC = {
                DRAW_WITH_TEXTURE:[
                    [
                        'attribute vec3 a_position;',
                        'attribute vec2 a_texcoord;',

                        'uniform mat4 u_matrix;',
                        'uniform mat4 u_textureMatrix;',

                        'varying vec2 v_texcoord;',

                        'void main() {',
                        'gl_Position = u_matrix * vec4(a_position,1);',
                        'v_texcoord = (u_textureMatrix * vec4(a_texcoord, 0, 1)).xy;',
                        '}'
                    ].join('\n'),

                    [
                        'precision mediump float;',

                        'varying vec2 v_texcoord;',

                        'uniform sampler2D texture;',
                        'uniform vec4 u_color; ',
                        'uniform float u_colorImpact;',

                        'void main() {',
                        'gl_FragColor = texture2D(texture, v_texcoord);',
                        '}'
                    ].join('\n')
                ]

            };
        }
    };


    modules.GlShader = {
        exports: function(module){
            module.exports.GlShader = function(gl,vShader, fShader){

                var GlUtils = require('GlUtils');

                var program;
                var uniforms;

                (function(){
                    if (!(vShader && fShader)) throw 'can not create GlShader: vertex and fragment shader source must be specified!';
                    program = GlUtils.createProgram(gl, vShader, fShader);
                    if (!program) throw 'can not create webgl program';
                    uniforms = GlUtils.extractUniforms(gl,program);
                })();

                this.bind = function(){
                    gl.useProgram(program);
                };

                this.setUniform = function(name,value){
                    var uniform = uniforms[name];
                    if (!uniform) throw 'no uniform with name '+ name + ' found!';
                    var setter = GlUtils.getUniformSetter(uniform);
                    setter(gl,uniform.location,value);
                };

                this.getProgram = function(){
                    return program;
                };


            };
        }
    };

    modules.VertexBuffer = {
        exports: function(module){

            module.exports.VertexBuffer = function(gl,shader){
                var buffer = gl.createBuffer();

                this.bindBufferData = function(bufferData, itemSize, uniformLocationName){
                    var uniformLocation = gl.getAttribLocation(shader.getProgram(), uniformLocationName); // todo cache locations
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.enableVertexAttribArray(uniformLocation);
                    gl.vertexAttribPointer(
                            uniformLocation,
                            itemSize,
                            gl.FLOAT,
                            false,  // if the content is normalized vectors
                            0,  // number of bytes to skip in between elements
                            0
                    ); // offsets to the first element
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(bufferData), gl.STATIC_DRAW);
                };
            };

        }
    };


    modules.Texture = {
        exports: function(module){
            module.exports.Texture = function(gl,img){

                var tex;
                var size;

                this.bind = function(){
                    gl.bindTexture(gl.TEXTURE_2D, tex);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                };

                this.setSize = function(_size){
                    size = _size;
                };

                this.getSize = function(){
                    return size;
                };

                this.getGlTexture = function(){
                    return tex;
                };

                (function(){
                    tex = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, tex);
                    // Fill the texture with a 1x1 blue pixel.
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                            new Uint8Array([0, 0, 255, 255]));

                    // let's assume all images are not a power of 2
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                })();

            };
        }
    };


    modules.FrameBuffer = {
        exports: function(module){

            module.exports.FrameBuffer = function(gl,width,height){

                var glTexture;
                var glRenderBuffer;
                var glFrameBuffer;

                this.bind = function(){
                    gl.bindFramebuffer(gl.FRAMEBUFFER, glFrameBuffer);
                    gl.viewport(0, 0, width,height);
                };

                this.unbind = function(){
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                };

                this.getGlTexture = function(){
                    return glTexture;
                };


                (function(){

                    //1. Init Color Texture
                    glTexture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, glTexture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                    //2. Init Render Buffer
                    glRenderBuffer = gl.createRenderbuffer();
                    gl.bindRenderbuffer(gl.RENDERBUFFER, glRenderBuffer);
                    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
                    //3. Init Frame Buffer
                    glFrameBuffer = gl.createFramebuffer();
                    gl.bindFramebuffer(gl.FRAMEBUFFER, glFrameBuffer);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTexture, 0);
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, glRenderBuffer);
                    //4. Clean up
                    gl.bindTexture(gl.TEXTURE_2D, null);
                    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);


                })();

            };

        }
    };


    modules.GlContext = {
        exports: function(module){

            var GlUtils = require('GlUtils');
            var GlShader = require('GlShader');
            var ShaderSources = require('ShaderSources');
            var VertexBuffer = require('VertexBuffer');
            var FrameBuffer = require('FrameBuffer');
            var Texture = require('Texture');
            var Mat4 = require('Mat4');

            module.exports.GlContext = function () {

                var gl;
                var mCanvas;
                var matrixStack = new GlUtils.MatrixStack();
                var simpleTextureShader;
                var vertexPositionBuffer;
                var vertexTextureBuffer;
                var frameBuffer;
                var vertexPositionData = [
                    0, 0, 0,
                    0, 1, 0,
                    1, 0, 0,
                    1, 0, 0,
                    0, 1, 0,
                    1, 1, 0
                ];
                var vertexTextureData = [
                    0, 0,
                    0, 1,
                    1, 0,
                    1, 0,
                    0, 1,
                    1, 1
                ];


                this.init = function (canvas) {

                    mCanvas = canvas;
                    gl = canvas.getContext("webgl", {alpha: false}) ||  canvas.getContext("experimental-webgl", {alpha: false});

                    simpleTextureShader = new GlShader.GlShader(gl,ShaderSources.SHADERS_SRC.DRAW_WITH_TEXTURE[0],ShaderSources.SHADERS_SRC.DRAW_WITH_TEXTURE[1]);
                    simpleTextureShader.bind();

                    vertexPositionBuffer = new VertexBuffer.VertexBuffer(gl,simpleTextureShader);
                    vertexPositionBuffer.bindBufferData(vertexPositionData,3,'a_position');

                    vertexTextureBuffer = new VertexBuffer.VertexBuffer(gl,simpleTextureShader);
                    vertexTextureBuffer.bindBufferData(vertexTextureData,2,'a_texcoord');

                    frameBuffer = new FrameBuffer.FrameBuffer(gl,mCanvas.width,mCanvas.height);

                    gl.disable(gl.CULL_FACE);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                    gl.enable(gl.BLEND);
                    gl.enable(gl.DEPTH_TEST);
                    this.resize(mCanvas.width,mCanvas.height)

                };

                function createPositionMatrix(dstX, dstY, dstWidth, dstHeight) {
                    // this matrix will convert from pixels to clip space
                    var projectionMatrix = Mat4.make2DProjection(mCanvas.width, mCanvas.height, 500);
                    //var aspect = mCanvas.width / mCanvas.height;
                    //var projectionMatrix = Mat4.makePerspective(1.047, aspect, 1, 2000);


                    // this matrix will scale our 1 unit quad
                    // from 1 unit to dstWidth, dstHeight units
                    var scaleMatrix = Mat4.makeScale(dstWidth, dstHeight, 1);

                    // this matrix will translate our quad to dstX, dstY
                    var translationMatrix = Mat4.makeTranslation(dstX, dstY, 0);

                    // multiply them all togehter
                    var matrix = Mat4.matrixMultiply(scaleMatrix, translationMatrix);
                    matrix = Mat4.matrixMultiply(matrix, matrixStack.getCurrentMatrix());
                    matrix = Mat4.matrixMultiply(matrix, projectionMatrix);
                    matrix = Mat4.matrixMultiply(matrix, Mat4.makeZToWMatrix(0.05));

                    return matrix;
                }

                function createTextureMatrix(srcX, srcY, srcWidth, srcHeight, texWidth, texHeight){
                    // Because texture coordinates go from 0 to 1
                    // and because our texture coordinates are already a unit quad
                    // we can select an area of the texture by scaling the unit quad
                    // down
                    var texScaleMatrix = Mat4.makeScale(srcWidth / texWidth , srcHeight / texHeight, 1);
                    var texTranslationMatrix = Mat4.makeTranslation(srcX / texWidth, srcY / texHeight, 0);

                    // multiply them together
                    return Mat4.matrixMultiply(texScaleMatrix, texTranslationMatrix);
                }


                this.loadTexture = function (url, callBack) {
                    var img = new Image();
                    var texture = new Texture.Texture(gl,img);

                    img.addEventListener('load', function () {
                        texture.setSize({
                            width:img.width,
                            height:img.height
                        });
                        callBack(texture);
                    });
                    img.src = url;
                };

                this.drawImage = function (texture,
                                           srcX, srcY, srcWidth, srcHeight,
                                           dstX, dstY) {

                    var tex = texture.getGlTexture();
                    var texWidth = texture.getSize().width;
                    var texHeight = texture.getSize().height;


                    if (dstX === undefined) {
                        dstX = srcX;
                    }
                    if (dstY === undefined) {
                        dstY = srcY;
                    }
                    if (srcWidth === undefined) {
                        srcWidth = texWidth;
                    }
                    if (srcHeight === undefined) {
                        srcHeight = texHeight;
                    }

                    texture.bind();
                    simpleTextureShader.setUniform('u_matrix',createPositionMatrix(dstX, dstY, srcWidth, srcHeight));
                    simpleTextureShader.setUniform('u_textureMatrix',createTextureMatrix(srcX, srcY, srcWidth, srcHeight, texWidth, texHeight));

                    // draw the quad (2 triangles, 6 vertices)
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                };

                this.clear = function () {
                    //gl.colorMask(false, false, false, true);
                    gl.clearColor(1, 1, 1, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                };


                this.fillRect = function (x, y, w, h, color) {
                    simpleTextureShader.setUniform('u_matrix',createPositionMatrix(x, y, w, h));
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                };

                this.strokeRect = function (x, y, w, h, color) {
                    this.fillRect(x, y, w, 1, color);
                    this.fillRect(x, y + h, w, 1, color);
                    this.fillRect(x, y, 1, h, color);
                    this.fillRect(x + w, y, 1, h, color);
                };

                this.point = function (x, y, color) {
                    this.fillRect(x, y, 1, 1, color);
                };

                this.line = function (x1, y1, x2, y2, color) {
                    simpleTextureShader.setUniform('u_matrix',createPositionMatrix(x1, y1, x2 - x1, y2 - y1));
                    gl.drawArrays(gl.LINES, 0, 6);
                };

                this.save = function() {
                    matrixStack.save();
                };

                this.resize = function (w,h) {
                    gl.viewport(0, 0, w,h);
                };

                this.scale = function(x,y) {
                    matrixStack.scale(x,y);
                };

                this.rotateZ = function(angleInRadians) {
                    matrixStack.rotateZ(angleInRadians);
                };

                this.rotateY = function(angleInRadians) {
                    matrixStack.rotateY(angleInRadians);
                };

                this.translate = function(x,y){
                    matrixStack.translate(x,y);
                };

                this.restore = function(){
                    matrixStack.restore();
                };

                this.beginFrameBuffer = function(){
                    this.save();
                    frameBuffer.bind();
                };

                this.flipFrameBuffer = function(){
                    this.restore();
                    this.save();
                    this.translate(0,mCanvas.height);
                    this.scale(1,-1);
                    frameBuffer.unbind();
                    gl.bindTexture(gl.TEXTURE_2D, frameBuffer.getGlTexture());
                    simpleTextureShader.setUniform('u_matrix',createPositionMatrix(0,0,mCanvas.width, mCanvas.height),1);
                    simpleTextureShader.setUniform('u_textureMatrix',createTextureMatrix(0,0,mCanvas.width, mCanvas.height,mCanvas.width, mCanvas.height));
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    this.restore();
                };

                this.getGL = function(){
                    return gl;
                }

            }

        }
    };


    modules.Main = {
        exports: function(module){

            var GlContext = require('GlContext');

            window.addEventListener('load', function () {
                var ctx = new GlContext.GlContext();
                var gl = ctx.getGL();
                var a = 0;
                ctx.init(document.getElementById('canvas'));

                ctx.loadTexture('particle.png', function (particle) {
                    ctx.loadTexture('ptr2.jpg', function (ptr) { // 86 117
                        setInterval(function () {

                            ctx.beginFrameBuffer();

                            ctx.clear(600, 600);
                            ctx.translate(100, 100);
                            ctx.rotateY(a);
                            ctx.translate(86 / -2, 117 / -2);

                            a += 0.1;
                            ctx.drawImage(ptr, 0, 0, 86, 117, 0, 0);
                            ctx.rotateY(a *.1);
                            ctx.drawImage(ptr, 0, 0, 86, 117, 20, 20);

                            ctx.restore();
                            ctx.drawImage(ptr,0,0,300,168,0,0);

//                    ctx.drawImage(particle,0,0,128,128,0,0,128,128);
//                    ctx.drawImage(particle,0,0,128,128,20,20,128,128);
//                    ctx.strokeRect(55,1,120,22,[0,255,0,255],1);
//                    ctx.point(12,12,[255,0,0,255]);
                            // ctx.line(10, 10, 100, 100, [255, 0, 0, 255]);

                            ctx.flipFrameBuffer();

                        }, 100);
                    });
                });
            });

        }
    };

    require('Main');




</script>



</body>
</html>